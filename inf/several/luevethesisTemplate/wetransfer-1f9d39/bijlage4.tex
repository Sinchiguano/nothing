\chapter{Application D: Take object}
\begin{lstlisting}
#include <ros/ros.h>
#include <capek_robot/CapekRobotCommander.h>

#include <controller_manager_msgs/SwitchController.h>

#include <sensor_msgs/JointState.h>
#include <papouch_ros/WriteIO.h>


bool switch_controllers(int controller_mode) {

    controller_manager_msgs::SwitchController srv_switch;
    srv_switch.request.strictness = controller_manager_msgs::SwitchController::Request::BEST_EFFORT;

    if (controller_mode == 0) {
        srv_switch.request.start_controllers.push_back("trajectory_controller");
        srv_switch.request.stop_controllers.push_back("compliance_controller");
        srv_switch.request.stop_controllers.push_back("gravity_compensation_controller");
    } else if(controller_mode == 2){
        srv_switch.request.start_controllers.push_back("gravity_compensation_controller");
        srv_switch.request.stop_controllers.push_back("compliance_controller");
        srv_switch.request.stop_controllers.push_back("trajectory_controller");
    } else{
        srv_switch.request.start_controllers.push_back("compliance_controller");
        srv_switch.request.stop_controllers.push_back("gravity_compensation_controller");
        srv_switch.request.stop_controllers.push_back("trajectory_controller");
    }

    if (!ros::service::call("/r1/controller_manager/switch_controller", srv_switch)) {
        ROS_ERROR_STREAM("Cannot switch controllers.");
        return false;
    }

    return true;
}
bool grabbingObject(papouch_ros::WriteIO &close_gripper){

	//Close gripper
	ROS_INFO_STREAM("Close Gripper");
	if (!ros::service::call("/write_io", close_gripper)) {
		ROS_ERROR_STREAM("Cannot close gripper.");
		return false;
	}
	ROS_INFO_STREAM("Grabbed object");

}


bool releaseObject(CapekRobotCommander &crc, papouch_ros::WriteIO &open_gripper){
	
	//Open gripper
	ROS_INFO_STREAM("Open Gripper");
	if (!ros::service::call("/write_io", open_gripper)) {
		ROS_ERROR_STREAM("Cannot open gripper.");
		return false;
	}
	ROS_INFO_STREAM("Object released");

}


int putObjectOnTable(CapekRobotCommander &crc, papouch_ros::WriteIO &open_gripper){

	//Move robot 10 cm backwards
	robot_state::RobotState state = *crc.getCurrentState();
	moveit_msgs::RobotTrajectory rtraj;

	Eigen::Affine3d A = state.getGlobalLinkTransform("r1_ee");
	Eigen::Affine3d B = A * Eigen::Translation3d(0.0, 0.0, -0.10);
	
	crc.computeCartesianPath(rtraj, {B}, "r1_ee", "r1_arm");
	crc.execute(rtraj.joint_trajectory);

	//Move to loose position
	state = *crc.getCurrentState();

	const Eigen::Affine3d base = state.getGlobalLinkTransform("pallet1");
	const Eigen::Affine3d grip_rot = Eigen::Affine3d::Identity() * 
	Eigen::AngleAxisd(M_PI_2, Eigen::Vector3d::UnitY()) * 
	Eigen::AngleAxisd(-M_PI_2, Eigen::Vector3d::UnitZ());
	const auto T = Eigen::Translation3d(0.7, -0.2, 0.1);

	if(!state.setFromIK(state.getJointModelGroup(CapekRobotCommander::GROUP_R1_ARM),
	base * T * grip_rot,"r1_ee")) {
		ROS_WARN_STREAM("Cannot solve IKT");
		return -1;
	}
	crc.setJointValueTarget(state);

	if (!crc.move()) {
		ROS_ERROR_STREAM("Cannot move to defined position");
		return -1;
	}
	
	//Open gripper
	releaseObject(crc, open_gripper);
	ros::Duration(1.0).sleep();

	//Move robot 10 cm backwards
	state = *crc.getCurrentState();
	Eigen::Affine3d C = state.getGlobalLinkTransform("r1_ee");
	Eigen::Affine3d D = C * Eigen::Translation3d(0.0, 0.0, -0.10);

	crc.computeCartesianPath(rtraj, {D}, "r1_ee", "r1_arm");
	crc.execute(rtraj.joint_trajectory);

	ROS_INFO_STREAM("Placed the object on the table");

}


int moveToStartPosition(CapekRobotCommander &crc){

	robot_state::RobotState state = *crc.getCurrentState();
	state.setToDefaultValues();
	state.setVariablePosition("r1_joint_1", -M_PI/3.0);
	state.setVariablePosition("r1_joint_2", M_PI/4.5);
	state.setVariablePosition("r1_joint_3", 0.0);
	state.setVariablePosition("r1_joint_4", -M_PI/1.8);
	state.setVariablePosition("r1_joint_5", 0.0);
	state.setVariablePosition("r1_joint_6", -M_PI/3.0);
	state.setVariablePosition("r1_joint_7", -M_PI_2);
	crc.setJointValueTarget(state);

	if (!crc.move()) {
		ROS_ERROR_STREAM("Cannot move to start position");
		return -1;
	}

	ROS_INFO_STREAM("Moved to start position");
}


int moveToInitialPosition(CapekRobotCommander &crc, papouch_ros::WriteIO &open_gripper){

	//Move robot to initial position
	crc.moveToNamedTarget(crc.NAMED_TARGET_L);

	if (!crc.move()) {
		ROS_ERROR_STREAM("Cannot move to initial position");
		return -1;
	}

	//Move gripper to initial position
	if (!ros::service::call("/write_io", open_gripper)) {
		ROS_ERROR_STREAM("Cannot open gripper.");
		return -1;
	}

	ROS_INFO_STREAM("Moved to initial position");
}


int main(int argc, char **argv) {

	ROS_INFO_STREAM("Application D started: Giving an object to the robot.");


	//Initializing the node
	ros::init(argc, argv, "applicationD_take_object");
	ros::NodeHandle n;

	ros::AsyncSpinner spinner(2);
	spinner.start();

	ROS_INFO_STREAM("Node initialized");

	
	//Declare robot commander and services
	CapekRobotCommander crc(crc.GROUP_R1_ARM);
	crc.setRobotSpeed(1.0);

	papouch_ros::WriteIO open_gripper;
	papouch_ros::WriteIO close_gripper;

	std::vector<int8_t> channel_open;
	channel_open.resize(2);
	channel_open[0] = 2;
	channel_open[1] = 1;

	std::vector<int8_t> state_open;
	state_open.resize(2);
	state_open[0] = 0;
	state_open[1] = 1;

	std::vector<int8_t> channel_close;
	channel_close.resize(2);
	channel_close[0] = 1;
	channel_close[1] = 2;

	std::vector<int8_t> state_close;
	state_close.resize(2);
	state_close[0] = 0;
	state_close[1] = 1;

	open_gripper.request.channel = channel_open;
	open_gripper.request.state = state_open;
	close_gripper.request.channel = channel_close;
	close_gripper.request.state = state_close;

	
	//Set controller mode to mode 0 (Trajectory mode)
	if (!switch_controllers(0)) {
		ROS_ERROR_STREAM("Cannot set to mode 0");
		return -1;
	}

	ROS_INFO_STREAM("Controller mode set to mode 0 (Trajectory mode)");

	
	//Move to initial position
	moveToInitialPosition(crc, open_gripper);


	//Move to start position
	moveToStartPosition(crc);


	//Taking the object cycle
	while(ros::ok()){


		//Wait till object is detected
		ROS_INFO_STREAM("Ready to take the object");

		sensor_msgs::JointState r1_joint_states;

		do{
			auto msg = ros::topic::waitForMessage<sensor_msgs::JointState>("/r1/joint_states", n);
			r1_joint_states = *msg;
			ROS_INFO_STREAM(r1_joint_states.effort[3]);
		}while(r1_joint_states.effort[3] > -9.0);


		//Grab object
		grabbingObject(close_gripper);
		ros::Duration(1.0).sleep();


		//Put object on the table
		putObjectOnTable(crc, open_gripper);


		//Move back to start position
		moveToStartPosition(crc);

	}

	ros::waitForShutdown();


	//Set controller mode to mode 0 (Trajectory mode)
	if (!switch_controllers(0)) {
		ROS_ERROR_STREAM("Cannot set to mode 0");
		return -1;
	}

	ROS_INFO_STREAM("Controller mode set to mode 0 (Trajectory mode)");


	//Move to initial position
	moveToInitialPosition(crc, open_gripper);

	ROS_INFO_STREAM("End of application");

	return 0;
}
\end{lstlisting}
