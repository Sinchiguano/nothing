\chapter{Force controller on application level}

\begin{lstlisting}
#include <ros/ros.h>
#include <capek_robot/CapekRobotCommander.h>

#include <iiwa_kinematic/Jacobian.h>
#include <cmath>

double filter(double x, double x0){
    if (std::abs(x) > x0) {
        return x;
    }
    return 0.0;
}

int sgn(double v) {
  if (v < 0) return -1;
  if (v > 0) return 1;
  return 0;
}

int applyConstantForce(CapekRobotCommander &crc){
	
	sensor_msgs::JointState r1_joint_states;
	Eigen::Matrix<double, 7, 1> cmd;
	Eigen::Matrix<double, 7, 1> efforts;
	Eigen::Matrix<double, 6, 1> Fu;
	Fu << 0.0, 0.0, 0.0, 0.0, 0.0, 0.0; 

	auto msg = ros::topic::waitForMessage<sensor_msgs::JointState>("/r1/joint_states");
	r1_joint_states = *msg;

	for (size_t i = 0; i < efforts.size(); ++i) {
        	efforts(i, 0) = r1_joint_states.effort[i];
		         cmd(i, 0) = r1_joint_states.position[i];
	}

	Jacobian jac;
	//use the last commanded position to compute the Jacobian
	const auto J = jac.computeJacobian(cmd); 
	const Eigen::Matrix<double, 6, 7> pinv = (J * J.transpose()).inverse() * J;
	Eigen::Matrix<double, 6, 1> Fm = pinv * efforts; //cartesian forces/moments

	Fm[0]=0;Fm[2]=0;Fm[3]=0;Fm[4]=0;Fm[5]=0;

	for (size_t i = 0; i < 6; ++i) { //filter
            Fm[i] = filter(Fm[i], 1.0);
	} 

	Eigen::Matrix<double, 6, 1> dF = Fm - Fu;

	double x = 1000;
	double y = 1000;
	double z = 1000;
	double a = 1000;
	double b = 1000;
	double c = 1000;

	Eigen::Matrix<double, 6, 6> K;

	K <<    x,    0,     0,      0,    0,    0,
        	0,    y,     0,      0,    0,    0,
        	0,    0,     z,      0,    0,    0,
        	0,    0,     0,      a,    0,    0,
        	0,    0,     0,      0,    b,    0,
        	0,    0,     0,      0,    0,    c;

	Eigen::Matrix<double, 6, 1> dX = K.inverse()*dF;
	Eigen::Matrix<double, 7, 1> dq = J.transpose() * (J * J.transpose()).inverse() * dX;

	auto cmd_new = cmd;
	cmd_new += dq;

	CapekRobotCommander::Plan plan;

	auto state = *crc.getCurrentState();
	state.setToDefaultValues();
	state.setVariablePosition("r1_joint_1", cmd_new[0]);
	state.setVariablePosition("r1_joint_2", cmd_new[1]);
	state.setVariablePosition("r1_joint_3", cmd_new[2]);
	state.setVariablePosition("r1_joint_4", cmd_new[3]);
	state.setVariablePosition("r1_joint_5", cmd_new[4]);
	state.setVariablePosition("r1_joint_6", cmd_new[5]);
	state.setVariablePosition("r1_joint_7", cmd_new[6]);
	crc.setJointValueTarget(state);

	crc.plan(plan);
	crc.showTrajectory(plan);

	if (!crc.execute(plan)) {
		    ROS_ERROR_STREAM("Cannot move to defined position");
		    return -1;
	}
	
}
\end{lstlisting}
